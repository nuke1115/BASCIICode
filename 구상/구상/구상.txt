이름 : BASCIICode <= Brainfuck이라는 난해한 프로그래밍 언어에서 이름을 따왔다
확장자 : .BASCIICode

문법: 기본적으로 Brainfuck의 문법을 따라간다

작동 방식: 파일의 코드를 읽어온다
명령어 인덱스를 코드 하나를 실행시킬때마다 +1 씩 옮긴다
명령어 인덱스가 가리키고 있는 셀의 코드를 읽고, 읽은 코드의 아스키코드 값을 10으로 나눈 나머지의 결과에 따라 함수를 호출한다

각 값에 대응하는 명령어는 다음과 같다

0 => 프로그램 종료
1 => 값 인덱스를 왼쪽으로 1 옮긴다
2 => 값 인덱스를 오른쪽으로 1 옮긴다
3 => 값 인덱스가 가리키고 있는 셀의 값을 1 증가시킨다
4 => 값 인덱스가 가리키고 있는 셀의 값을 1 감소시킨다
5 => 값 인덱스가 가리키고 있는 셀의 값을 아스키코드의 형태로 출력한다
6 => 값 인덱스가 가리키고 있는 셀에 아스키코드의 형태로 값을 입력한다

7,8는 루프문 관련 명령어다
7 => 만약 값 포인터가 가리키고 있는 셀의 값이 0이면, 루프 맵에서 현재 루프의 끝에 해당하는 위치값을 꺼내와서 명령어 인덱스를 해당 위치로 이동하고, 아니라면 그냥 지나간다.
8 => 만약 값 포인터가 가리키고 있는 셀의 값이 0이 아니면, 루프 맵에서 현재 루프의 시작에 해당하는 위치값을 꺼내와서 명령어 인덱스를 해당 위치로 이동하고, 아니라면 그냥 지나간다.

9 => 값 인덱스가 가리키고 있는 셀의 값을 정수 형태로 출력한다
		
구조:
명령어 배열&명령어 인덱스
값 배열&값 인덱스
루프 맵
배열과 인덱스, 맵들은 interpreter 클래스에 포함되있다





[]

[[[]]]
[[][]]
==========
인터프리터 형식의 esolang

코드 읽어오는것 <= 완료
코드를 읽고 아스키 코드에 맞는 문자를 명령어 배열에 할당 해주기 ,  인덱스가 움직이는 최대값에 맞춰서 값 배열 할당하기 <= parser <= 완료
[0=>E 1=>> 2=>< 3=>+ 4=>- 5=>A 6=>S =>  7 => [ 8=> ] 9 =>D]
명령어 테이블 <= commandTable <= 완료
명령어 배열을 읽고 명령어 테이블에 있는 명령어를 실행하는것 <= executer <= 완료
main.cpp

TODO input함수 값 입력 오류 수정
=====
주제:간단한 형태의 난해한 프로그래밍 언어 만들어보기
동기:시험기간중에 갑자기 난해한 프로그래밍 언어를 만들고싶다는 생각이 들었는데, 시험이 끝나고 방학 시작하기 전에 만들어보고자 하여 해보게 되었다(임시)
배경지식: 인터프리터와 관련한것 , 난해한 프로그래밍 언어와 관련한것
과정:만드는 과정/오류 해결 <= 사진과 함께
결과:이 언어로 만든 간단한 프로그램 몇개와 설명 <= 깃허브 링크도 첨부
소감:
자료출처:

=========
동기:인터넷을 돌아다니던 중에 난해한 프로그래밍 언어에 대해 다루는 글을 보았다.
글을 다 나니 직접 만들어보는것도 괜찮은 경험일거라 생각하여,
현제 만들어진 언어들중 가장 간단하며 잘 알려진 언어인 Brainfuck이라는 언어에 약간의 변형을 가하여 만들어보기로 하였다



/집에서 무언가를 제작해보는것을 즐겨하는데, 다음으로 만들것에 대한 주제를 찾기 위해 인터넷을 찾아보던중 난해한 프로그래밍 언어에 대해 다룬 글을 보았다.
그 글을 보고 나니 쓰기 편하게 만드는게 아닌, 오히려 어렵게 만드는 난해한 프로그래밍 언어에 대해 관심이 생겼고,
직접 만들어보는것도 괜찮은 경험이라 생각하여, 현재 만들어진 난해한 프로그래밍 언어중
간단한 구조인 Brainfuck이라는 언어를 기반으로 약간의 변형을 가해 새로운 난해한 프로그래밍 언어를 만들어보고자 한다.

=>흐름은 괜찮은데
,사용은 자제하는게 좋아요
불필요한 ,은 빼고
호흡이 긴 문장은 두 개로 쪼개요
그리고 접속사? 라고 해야 하나
~일 것 같다
~라고 생각해서
~했는데 그리고 등등 자제


/평소에 무언가를 만들어보는 것을 즐기는 편이
시험이 끝나서, 다음으로 만들 것의 아이디어를 얻기 위해 인터넷을 찾아보던 중 난해한 프로그래밍 언어에 대해 다룬 글을 보았다.
쓰기 편하기 위해 만드는 것이 아닌, 오히려 쓰기 어렵게 만드는 난해한 프로그래밍 언어에 관해 관심이 생겼고, 직접 만드는 것도 괜찮은 경험일 거라 생각해 다음으로 만들것을 이것으로 정했다.
만들기 위해 더 찾아보던 중 Brainfuck이라는 언어를 찾았고, 간단한 형태라 변형하기 적절할 거라 생각해 이 언어에 약간의 변형을 가해 난해한 프로그래밍 언어를 만들어보게 되었다.

/평소에 무언가를 만들어보는 것을 즐겨한다.
시험이 끝나고 방학까지의 기간 동안 무언가를 만들어 보고자 아이디어를 얻기 위해 인터넷을 찾아보던 중 난해한 프로그래밍 언어에 대해 다룬 글을 보았다. 쓰기 편하기 위해 만드는 것이 아닌, 오히려 쓰기 어렵게 만드는 난해한 프로그래밍 언어는 상당히 흥미로웠다. 이것을 직접 만들어보는 것도 괜찮은 경험일 거라 생각해 자료를 더 찾아보던 중 Brainfuck이라는 언어를 찾았다. 언어의 구조가 상당히 단순해 변형을 가하기 적절할 것이라 판단해 이 언어에 약간의 변형을 가해 새로운 난해한 프로그래밍 언어를 만들어보았다.



목적:난해한 프로그래밍 언어에 대해 탐구해보고, 직접 만들어본다.
=========
난해한 프로그래밍 언어, 튜링 완전성,인터프리터

난해한 프로그래밍 언어:
정의:실제로 사용할 목적으로 만들어졌기보다는 ,아이디어나 프로그래밍 언어의 한계를 실험하거나 사용하기 어렵게 만들거나, 또는 단순히 재미를 위해서 만들어진 프로그래밍 언어다. <- esolang.org의 내용에서 발췌
종류:종류는 esolang.org라는 난해한 프로그래밍 언어들을 모아두는 위키에 따르면 다음과 같다.
미니멀리즘(최소주의) : 프로그램을 작성하는데에 필요한 명령어의 수를 최대한 적게 만든 언어들.
난해함:사용하기가 어렵게 하는것을 목표로 만들어진 언어들.(사용하기가 불가능에 가까운것도 있다)
테마:컴퓨터와는 거리가 멀어보이는 테마를 가진 언어들.
간결함:가능한 짧게 코드를 짤수 있게 만든 언어들. (코드골프를 위해 주로 사용된다)
농담/유머:단순히 재미를 위해 만든 언어로, 위의 모든 분류를 포함해 대부분의 난해한 프로그래밍 언어들이 이 목적으로 만들어진다.
<- esolang.org에서 발췌
주의할점:단순히 읽고쓰기 어렵다고 해서 난해한 프로그래밍 언어는 아니다.
읽고 쓰기 난해하다고 하더라도, 실제로 사용되고 있고, 실제로 사용할 목적으로 만들어졌다면 (예를 들어 어셈블리어, 기계어) 난해한 프로그래밍 언어는 아니다.

/난해한 프로그래밍 언어:
정의:실제로 사용할 목적보다는, 아이디어나 프로그래밍 언어의 한계를 실험하기 위해서, 또는 단순히 재미를 위해 만들어진 언어들이다. 
따라서, 단순히 사용하기 어렵거나, 읽기 난해하다고 해서 난해한 프로그래밍 언어는 아니다. (대표적 예시로 어셈블리어와 기계어가 있다. 둘 다 읽고 쓰기는 어렵고 난해하나, 실제로 사용되고 있고, 사용할 목적으로 만든 것이기에, 난해한 프로그래밍 언어는 아니다.)
(esolang.org - Esoteric Programming Language에서 발췌)

이렇게만 들으면 이게 과연 프로그래밍 언어는 맞는지, 이걸로 뭔가 프로그램이라 부를수 있을만한걸 만들수 있는지 의문점이 든다.
결론부터 말하면, 특정 조건을 만족하는 경우에는 가능하다 라고 할수 있다.
이것이 왜 가능한지 알아보려면 튜링머신과 튜링완전이라는 두가지 개념을 간단하게나마 알아야된다.
(튜링머신 내용)
(튜링완전 내용)
(위에 두개 기반으로 왜 가능하다 했는지 적기)



====



